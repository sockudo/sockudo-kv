//! Sentinel Configuration Persistence
//!
//! Handles saving and loading sentinel state to/from disk.

use std::fs::{self, File};
use std::io::{self, BufRead, BufReader, Write};
use std::path::{Path, PathBuf};
use std::sync::Arc;
use std::sync::atomic::Ordering;

use super::config::{MasterConfig, SentinelConfig};
use super::state::{MasterInstance, ReplicaInstance, SentinelInstance, SentinelState};

/// Configuration persistence manager
pub struct ConfigPersistence {
    config_path: PathBuf,
}

impl ConfigPersistence {
    /// Create a new persistence manager
    pub fn new(config_path: PathBuf) -> Self {
        Self { config_path }
    }

    /// Save current state to config file
    pub fn save(&self, config: &SentinelConfig, state: &SentinelState) -> io::Result<()> {
        let tmp_path = self.config_path.with_extension("tmp");
        let mut file = File::create(&tmp_path)?;

        // Write header
        writeln!(file, "# Sentinel configuration file")?;
        writeln!(file, "# Generated by sockudo-kv sentinel")?;
        writeln!(file)?;

        // Write basic config
        writeln!(file, "port {}", config.port)?;
        writeln!(
            file,
            "daemonize {}",
            if config.daemonize { "yes" } else { "no" }
        )?;

        if !config.pidfile.is_empty() {
            writeln!(file, "pidfile {}", config.pidfile)?;
        }

        if !config.logfile.is_empty() {
            writeln!(file, "logfile \"{}\"", config.logfile)?;
        }

        writeln!(file, "loglevel {}", config.loglevel)?;
        writeln!(file, "dir {}", config.dir)?;
        writeln!(file)?;

        // Write announce settings
        if let Some(ip) = &config.announce_ip {
            writeln!(file, "sentinel announce-ip {}", ip)?;
        }
        if let Some(port) = config.announce_port {
            writeln!(file, "sentinel announce-port {}", port)?;
        }

        writeln!(
            file,
            "sentinel resolve-hostnames {}",
            if config.resolve_hostnames {
                "yes"
            } else {
                "no"
            }
        )?;
        writeln!(
            file,
            "sentinel announce-hostnames {}",
            if config.announce_hostnames {
                "yes"
            } else {
                "no"
            }
        )?;
        writeln!(file)?;

        // Write myid
        writeln!(file, "sentinel myid {}", config.myid)?;

        // Write current epoch
        writeln!(file, "sentinel current-epoch {}", state.epoch())?;
        writeln!(file)?;

        // Write each monitored master
        for entry in state.masters.iter() {
            let master = entry.value();
            let master_config = master.config.read();
            let ip = master.ip.read().clone();
            let port = master.port.load(Ordering::Relaxed);

            // sentinel monitor
            writeln!(
                file,
                "sentinel monitor {} {} {} {}",
                master.name, ip, port, master_config.quorum
            )?;

            // sentinel down-after-milliseconds
            writeln!(
                file,
                "sentinel down-after-milliseconds {} {}",
                master.name, master_config.down_after_ms
            )?;

            // sentinel failover-timeout
            writeln!(
                file,
                "sentinel failover-timeout {} {}",
                master.name, master_config.failover_timeout
            )?;

            // sentinel parallel-syncs
            writeln!(
                file,
                "sentinel parallel-syncs {} {}",
                master.name, master_config.parallel_syncs
            )?;

            // sentinel auth-pass
            if let Some(pass) = &master_config.auth_pass {
                writeln!(file, "sentinel auth-pass {} {}", master.name, pass)?;
            }

            // sentinel auth-user
            if let Some(user) = &master_config.auth_user {
                writeln!(file, "sentinel auth-user {} {}", master.name, user)?;
            }

            // config-epoch
            writeln!(
                file,
                "sentinel config-epoch {} {}",
                master.name,
                master.config_epoch.load(Ordering::Relaxed)
            )?;

            // leader-epoch
            writeln!(
                file,
                "sentinel leader-epoch {} {}",
                master.name,
                master.leader_epoch.load(Ordering::Relaxed)
            )?;

            // Write known replicas
            for replica_entry in master.replicas.iter() {
                let replica = replica_entry.value();
                writeln!(
                    file,
                    "sentinel known-replica {} {} {}",
                    master.name, replica.ip, replica.port
                )?;
            }

            // Write known sentinels
            for sentinel_entry in master.sentinels.iter() {
                let sentinel = sentinel_entry.value();
                writeln!(
                    file,
                    "sentinel known-sentinel {} {} {} {}",
                    master.name,
                    sentinel.ip,
                    sentinel.port,
                    String::from_utf8_lossy(&sentinel.id)
                )?;
            }

            writeln!(file)?;
        }

        // Atomic rename
        fs::rename(&tmp_path, &self.config_path)?;

        log::debug!("Saved sentinel configuration to {:?}", self.config_path);
        Ok(())
    }

    /// Load configuration and state from file
    pub fn load(&self) -> io::Result<(SentinelConfig, SentinelState)> {
        let file = File::open(&self.config_path)?;
        let reader = BufReader::new(file);

        let mut config = SentinelConfig::default();
        let state = SentinelState::default();

        // Temporary storage for parsing
        let mut current_epoch = 0u64;
        let mut known_replicas: Vec<(String, String, u16)> = Vec::new();
        let mut known_sentinels: Vec<(String, String, u16, String)> = Vec::new();
        let mut config_epochs: Vec<(String, u64)> = Vec::new();
        let mut leader_epochs: Vec<(String, u64)> = Vec::new();

        for line in reader.lines() {
            let line = line?;
            let line = line.trim();

            // Skip comments and empty lines
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.is_empty() {
                continue;
            }

            match parts[0].to_lowercase().as_str() {
                "port" if parts.len() >= 2 => {
                    config.port = parts[1].parse().unwrap_or(26379);
                }
                "daemonize" if parts.len() >= 2 => {
                    config.daemonize = parts[1] == "yes";
                }
                "pidfile" if parts.len() >= 2 => {
                    config.pidfile = parts[1].to_string();
                }
                "logfile" if parts.len() >= 2 => {
                    config.logfile = unquote(parts[1]);
                }
                "loglevel" if parts.len() >= 2 => {
                    config.loglevel = parts[1].to_string();
                }
                "dir" if parts.len() >= 2 => {
                    config.dir = parts[1].to_string();
                }
                "sentinel" if parts.len() >= 2 => match parts[1].to_lowercase().as_str() {
                    "myid" if parts.len() >= 3 => {
                        config.myid = parts[2].to_string();
                    }
                    "current-epoch" if parts.len() >= 3 => {
                        current_epoch = parts[2].parse().unwrap_or(0);
                    }
                    "announce-ip" if parts.len() >= 3 => {
                        config.announce_ip = Some(parts[2].to_string());
                    }
                    "announce-port" if parts.len() >= 3 => {
                        config.announce_port = parts[2].parse().ok();
                    }
                    "resolve-hostnames" if parts.len() >= 3 => {
                        config.resolve_hostnames = parts[2] == "yes";
                    }
                    "announce-hostnames" if parts.len() >= 3 => {
                        config.announce_hostnames = parts[2] == "yes";
                    }
                    "monitor" if parts.len() >= 6 => {
                        let name = parts[2].to_string();
                        let ip = parts[3].to_string();
                        let port: u16 = parts[4].parse().unwrap_or(6379);
                        let quorum: u32 = parts[5].parse().unwrap_or(2);

                        let master_config =
                            MasterConfig::new(name.clone(), ip.clone(), port, quorum);
                        config.masters.insert(name.clone(), master_config.clone());

                        let master = MasterInstance::new(name.clone(), ip, port, master_config);
                        state.add_master(master);
                    }
                    "down-after-milliseconds" if parts.len() >= 4 => {
                        let name = parts[2];
                        let value: u64 = parts[3].parse().unwrap_or(30000);
                        if let Some(master) = state.get_master(name) {
                            master.config.write().down_after_ms = value;
                        }
                    }
                    "failover-timeout" if parts.len() >= 4 => {
                        let name = parts[2];
                        let value: u64 = parts[3].parse().unwrap_or(180000);
                        if let Some(master) = state.get_master(name) {
                            master.config.write().failover_timeout = value;
                        }
                    }
                    "parallel-syncs" if parts.len() >= 4 => {
                        let name = parts[2];
                        let value: u32 = parts[3].parse().unwrap_or(1);
                        if let Some(master) = state.get_master(name) {
                            master.config.write().parallel_syncs = value;
                        }
                    }
                    "auth-pass" if parts.len() >= 4 => {
                        let name = parts[2];
                        let value = parts[3].to_string();
                        if let Some(master) = state.get_master(name) {
                            master.config.write().auth_pass = Some(value);
                        }
                    }
                    "auth-user" if parts.len() >= 4 => {
                        let name = parts[2];
                        let value = parts[3].to_string();
                        if let Some(master) = state.get_master(name) {
                            master.config.write().auth_user = Some(value);
                        }
                    }
                    "config-epoch" if parts.len() >= 4 => {
                        let name = parts[2].to_string();
                        let epoch: u64 = parts[3].parse().unwrap_or(0);
                        config_epochs.push((name, epoch));
                    }
                    "leader-epoch" if parts.len() >= 4 => {
                        let name = parts[2].to_string();
                        let epoch: u64 = parts[3].parse().unwrap_or(0);
                        leader_epochs.push((name, epoch));
                    }
                    "known-replica" if parts.len() >= 5 => {
                        let master_name = parts[2].to_string();
                        let ip = parts[3].to_string();
                        let port: u16 = parts[4].parse().unwrap_or(6379);
                        known_replicas.push((master_name, ip, port));
                    }
                    "known-sentinel" if parts.len() >= 6 => {
                        let master_name = parts[2].to_string();
                        let ip = parts[3].to_string();
                        let port: u16 = parts[4].parse().unwrap_or(26379);
                        let id = parts[5].to_string();
                        known_sentinels.push((master_name, ip, port, id));
                    }
                    _ => {}
                },
                _ => {}
            }
        }

        // Apply current epoch
        state.current_epoch.store(current_epoch, Ordering::Relaxed);

        // Apply config epochs
        for (name, epoch) in config_epochs {
            if let Some(master) = state.get_master(&name) {
                master.config_epoch.store(epoch, Ordering::Relaxed);
            }
        }

        // Apply leader epochs
        for (name, epoch) in leader_epochs {
            if let Some(master) = state.get_master(&name) {
                master.leader_epoch.store(epoch, Ordering::Relaxed);
            }
        }

        // Add known replicas
        for (master_name, ip, port) in known_replicas {
            if let Some(master) = state.get_master(&master_name) {
                let replica = Arc::new(ReplicaInstance::new(ip.clone(), port));
                master.replicas.insert(format!("{}:{}", ip, port), replica);
            }
        }

        // Add known sentinels
        for (master_name, ip, port, id) in known_sentinels {
            if let Some(master) = state.get_master(&master_name) {
                let sentinel = Arc::new(SentinelInstance::new(
                    bytes::Bytes::from(id),
                    ip.clone(),
                    port,
                ));
                master
                    .sentinels
                    .insert(format!("{}:{}", ip, port), sentinel);
            }
        }

        // Update counts
        for entry in state.masters.iter() {
            entry.value().update_counts();
        }

        log::info!("Loaded sentinel configuration from {:?}", self.config_path);
        Ok((config, state))
    }

    /// Check if config file exists
    pub fn exists(&self) -> bool {
        self.config_path.exists()
    }
}

/// Remove quotes from a string
fn unquote(s: &str) -> String {
    let s = s.trim();
    if (s.starts_with('"') && s.ends_with('"')) || (s.starts_with('\'') && s.ends_with('\'')) {
        s[1..s.len() - 1].to_string()
    } else {
        s.to_string()
    }
}

/// Parse a sentinel.conf format configuration file
pub fn parse_sentinel_config(path: &Path) -> io::Result<(SentinelConfig, SentinelState)> {
    let persistence = ConfigPersistence::new(path.to_path_buf());
    persistence.load()
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_unquote() {
        assert_eq!(unquote("\"hello\""), "hello");
        assert_eq!(unquote("'hello'"), "hello");
        assert_eq!(unquote("hello"), "hello");
    }

    #[test]
    fn test_parse_config() {
        let mut file = NamedTempFile::new().unwrap();
        writeln!(file, "port 26379").unwrap();
        writeln!(file, "sentinel myid abc123def456789012345678901234567890").unwrap();
        writeln!(file, "sentinel monitor mymaster 127.0.0.1 6379 2").unwrap();
        writeln!(file, "sentinel down-after-milliseconds mymaster 5000").unwrap();

        let persistence = ConfigPersistence::new(file.path().to_path_buf());
        let (config, state) = persistence.load().unwrap();

        assert_eq!(config.port, 26379);
        assert_eq!(config.myid, "abc123def456789012345678901234567890");

        let master = state.get_master("mymaster").unwrap();
        assert_eq!(master.config.read().down_after_ms, 5000);
    }
}
